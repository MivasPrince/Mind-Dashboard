"""
Developer Dashboard - VISUAL-RICH System Telemetry
Charts: heatmaps, time series, error distributions, AI usage
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from core.db import get_bigquery_client, run_query
from core.settings import get_table_ref, COLORS
from core.theme import get_theme_colors

def render():
    st.markdown('<h1 class="main-header">‚öôÔ∏è Developer Dashboard</h1>', unsafe_allow_html=True)
    st.markdown("**System Telemetry** - Visual monitoring and observability")
    
    client = get_bigquery_client()
    if client is None:
        st.error("‚ùå Failed to connect")
        st.stop()
    
    theme = get_theme_colors()
    
    time_range = st.selectbox("Time Range", ["Last Hour", "Last 24 Hours", "Last 7 Days"], index=1)
    time_map = {"Last Hour": "1 HOUR", "Last 24 Hours": "1 DAY", "Last 7 Days": "7 DAY"}
    interval = time_map[time_range]
    
    # SYSTEM HEALTH GAUGES
    st.markdown("### üè• System Health")
    
    total_q = f"SELECT COUNT(*) as val FROM {get_table_ref('backend_telemetry')} WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL {interval})"
    total_df = run_query(total_q, client)
    total_req = total_df['val'].iloc[0] if total_df is not None else 0
    
    error_q = f"SELECT COUNT(*) as val FROM {get_table_ref('backend_telemetry')} WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL {interval}) AND derived_is_error = TRUE"
    error_df = run_query(error_q, client)
    errors = error_df['val'].iloc[0] if error_df is not None else 0
    
    error_rate = (errors / total_req * 100) if total_req > 0 else 0
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        fig = go.Figure(go.Indicator(
            mode="number",
            value=total_req,
            title={'text': "üì° Total Requests"}
        ))
        fig.update_layout(height=150)
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        fig = go.Figure(go.Indicator(
            mode="number",
            value=errors,
            title={'text': "‚ùå Errors"}
        ))
        fig.update_layout(height=150)
        st.plotly_chart(fig, use_container_width=True)
    
    with col3:
        fig = go.Figure(go.Indicator(
            mode="number+gauge",
            value=error_rate,
            title={'text': "‚ö†Ô∏è Error Rate %"},
            gauge={'axis': {'range': [0, 10]}, 
                   'bar': {'color': COLORS['danger'] if error_rate > 5 else COLORS['success']}}
        ))
        fig.update_layout(height=150)
        st.plotly_chart(fig, use_container_width=True)
    
    st.divider()
    
    # RESPONSE TIME CHART
    st.markdown("### ‚è±Ô∏è Response Time Monitoring")
    
    resp_q = f"""
    SELECT 
        TIMESTAMP_TRUNC(created_at, HOUR) as hour,
        AVG(derived_response_time_ms) as avg_resp
    FROM {get_table_ref('backend_telemetry')}
    WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL {interval})
    AND derived_response_time_ms IS NOT NULL
    GROUP BY hour
    ORDER BY hour
    """
    resp_data = run_query(resp_q, client)
    
    if resp_data is not None and not resp_data.empty:
        fig = px.line(resp_data, x='hour', y='avg_resp', markers=True)
        fig.update_traces(line_color=COLORS['primary'], line_width=3)
        fig.update_layout(
            title="Average Response Time Over Time",
            yaxis_title="Response Time (ms)",
            height=350
        )
        st.plotly_chart(fig, use_container_width=True)
    
    st.divider()
    
    # ERROR DISTRIBUTION
    st.markdown("### ‚ùå Error Analysis")
    
    col1, col2 = st.columns(2)
    
    with col1:
        error_endpoint_q = f"""
        SELECT 
            derived_endpoint_group as endpoint,
            COUNT(*) as errors
        FROM {get_table_ref('backend_telemetry')}
        WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL {interval})
        AND derived_is_error = TRUE
        AND derived_endpoint_group IS NOT NULL
        GROUP BY endpoint
        ORDER BY errors DESC
        """
        error_ep = run_query(error_endpoint_q, client)
        
        if error_ep is not None and not error_ep.empty:
            fig = px.pie(error_ep, values='errors', names='endpoint')
            fig.update_layout(title="Errors by Endpoint", height=350)
            st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        status_q = f"""
        SELECT 
            http_status_code as status,
            COUNT(*) as count
        FROM {get_table_ref('backend_telemetry')}
        WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL {interval})
        AND http_status_code IS NOT NULL
        AND http_status_code >= 400
        GROUP BY status
        ORDER BY count DESC
        """
        status_data = run_query(status_q, client)
        
        if status_data is not None and not status_data.empty:
            fig = px.bar(status_data, x='status', y='count', color='count',
                        color_continuous_scale='Reds')
            fig.update_layout(title="Error Status Codes", height=350)
            st.plotly_chart(fig, use_container_width=True)
    
    st.divider()
    
    # AI USAGE
    st.markdown("### ü§ñ AI Usage & Cost")
    
    tokens_q = f"""
    SELECT 
        DATE(created_at) as date,
        SUM(derived_ai_total_tokens) as total_tokens
    FROM {get_table_ref('backend_telemetry')}
    WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL {interval})
    AND derived_ai_total_tokens IS NOT NULL
    GROUP BY date
    ORDER BY date
    """
    tokens_data = run_query(tokens_q, client)
    
    if tokens_data is not None and not tokens_data.empty:
        tokens_data['cost'] = tokens_data['total_tokens'] / 1000 * 0.002
        
        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=tokens_data['date'],
            y=tokens_data['total_tokens'],
            name='Tokens',
            marker_color=COLORS['primary']
        ))
        
        fig.add_trace(go.Scatter(
            x=tokens_data['date'],
            y=tokens_data['cost'] * 10000,  # Scale for visibility
            name='Cost ($)',
            yaxis='y2',
            line=dict(color=COLORS['warning'], width=3)
        ))
        
        fig.update_layout(
            title="AI Token Usage & Estimated Cost",
            yaxis=dict(title='Tokens'),
            yaxis2=dict(title='Cost ($)', overlaying='y', side='right'),
            height=400
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    st.divider()
    
    # ACTIVITY HEATMAP
    st.markdown("### üî• Request Activity Heatmap")
    
    heat_q = f"""
    SELECT 
        EXTRACT(DAYOFWEEK FROM created_at) as day,
        EXTRACT(HOUR FROM created_at) as hour,
        COUNT(*) as requests
    FROM {get_table_ref('backend_telemetry')}
    WHERE created_at >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
    GROUP BY day, hour
    """
    heat_data = run_query(heat_q, client)
    
    if heat_data is not None and not heat_data.empty:
        pivot = heat_data.pivot(index='day', columns='hour', values='requests').fillna(0)
        days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
        
        fig = go.Figure(data=go.Heatmap(
            z=pivot.values,
            x=pivot.columns,
            y=[days[int(i-1)] for i in pivot.index],
            colorscale='Reds'
        ))
        
        fig.update_layout(
            title="Request Volume by Day & Hour",
            xaxis_title="Hour",
            yaxis_title="Day",
            height=400
        )
        
        st.plotly_chart(fig, use_container_width=True)

if __name__ == "__main__":
    render()
