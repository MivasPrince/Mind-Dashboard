"""
Admin Dashboard - VISUAL-RICH Institutional Analytics
Maximum visualizations: charts, graphs, heatmaps, trends
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
from core.db import get_bigquery_client, run_query
from core.settings import get_table_ref, COLORS
from core.theme import get_theme_colors

def create_kpi_chart(title, value, icon="üìä", delta=None):
    """Create visual KPI card"""
    theme = get_theme_colors()
    fig = go.Figure()
    
    fig.add_trace(go.Indicator(
        mode = "number+delta" if delta else "number",
        value = value,
        delta = {'reference': delta} if delta else None,
        title = {"text": f"{icon} {title}"},
        domain = {'x': [0, 1], 'y': [0, 1]}
    ))
    
    fig.update_layout(
        height=150,
        margin=dict(l=20, r=20, t=40, b=20),
        paper_bgcolor=theme['bg'],
        font=dict(color=theme['text'])
    )
    
    return fig

def render():
    """Render visual-rich admin dashboard"""
    
    st.markdown('<h1 class="main-header">üèõÔ∏è Admin Dashboard</h1>', unsafe_allow_html=True)
    st.markdown("**Institutional Analytics** - Visual insights for leadership")
    
    client = get_bigquery_client()
    if client is None:
        st.error("‚ùå Failed to connect to BigQuery")
        st.stop()
    
    theme = get_theme_colors()
    
    # ========================================================================
    # SECTION 1: EXECUTIVE KPI VISUALIZATIONS (4 GAUGE CHARTS)
    # ========================================================================
    
    st.markdown("### üìä Executive Metrics")
    
    with st.spinner("Loading metrics..."):
        # Get KPI data
        kpi_queries = {
            'users': f"SELECT COUNT(DISTINCT user_id) as val FROM {get_table_ref('user')}",
            'sessions': f"SELECT COUNT(*) as val FROM {get_table_ref('sessions')}",
            'avg_score': f"SELECT AVG(final_score) as val FROM {get_table_ref('grades')}",
            'engagement': f"SELECT AVG(derived_engagement_score) as val FROM {get_table_ref('session_analytics')} WHERE derived_engagement_score IS NOT NULL"
        }
        
        kpis = {}
        for key, query in kpi_queries.items():
            df = run_query(query, client)
            kpis[key] = df['val'].iloc[0] if df is not None and not df.empty else 0
    
    # Display as 4 gauge charts
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        fig = go.Figure(go.Indicator(
            mode="gauge+number",
            value=kpis['users'],
            title={'text': "üë• Total Users"},
            gauge={'axis': {'range': [None, kpis['users'] * 1.5]},
                   'bar': {'color': COLORS['primary']}}
        ))
        fig.update_layout(height=200, margin=dict(l=10, r=10, t=50, b=10))
        st.plotly_chart(fig, use_container_width=True, key="gauge1")
    
    with col2:
        fig = go.Figure(go.Indicator(
            mode="gauge+number",
            value=kpis['sessions'],
            title={'text': "üéØ Sessions"},
            gauge={'axis': {'range': [None, kpis['sessions'] * 1.5]},
                   'bar': {'color': COLORS['secondary']}}
        ))
        fig.update_layout(height=200, margin=dict(l=10, r=10, t=50, b=10))
        st.plotly_chart(fig, use_container_width=True, key="gauge2")
    
    with col3:
        fig = go.Figure(go.Indicator(
            mode="gauge+number",
            value=kpis['avg_score'],
            title={'text': "üìà Avg Score"},
            gauge={'axis': {'range': [0, 100]},
                   'bar': {'color': COLORS['success']}}
        ))
        fig.update_layout(height=200, margin=dict(l=10, r=10, t=50, b=10))
        st.plotly_chart(fig, use_container_width=True, key="gauge3")
    
    with col4:
        fig = go.Figure(go.Indicator(
            mode="gauge+number",
            value=kpis['engagement'],
            title={'text': "‚ö° Engagement"},
            gauge={'axis': {'range': [0, 100]},
                   'bar': {'color': COLORS['warning']}}
        ))
        fig.update_layout(height=200, margin=dict(l=10, r=10, t=50, b=10))
        st.plotly_chart(fig, use_container_width=True, key="gauge4")
    
    st.divider()
    
    # ========================================================================
    # SECTION 2: USER GROWTH & ADOPTION (LINE + AREA CHARTS)
    # ========================================================================
    
    st.markdown("### üìà User Growth & Adoption")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Daily Active Users - LINE CHART
        dau_query = f"""
        SELECT 
            DATE(timestamp) as date,
            COUNT(DISTINCT user) as active_users
        FROM {get_table_ref('conversation')}
        WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)
        GROUP BY date
        ORDER BY date
        """
        dau_data = run_query(dau_query, client)
        
        if dau_data is not None and not dau_data.empty:
            fig = px.line(dau_data, x='date', y='active_users',
                         title='üìÖ Daily Active Users (Last 30 Days)',
                         markers=True)
            fig.update_traces(line_color=COLORS['primary'], line_width=3)
            fig.update_layout(
                height=350,
                hovermode='x unified',
                plot_bgcolor=theme['bg'],
                paper_bgcolor=theme['bg'],
                font=dict(color=theme['text'])
            )
            st.plotly_chart(fig, use_container_width=True, key="dau_line")
        else:
            st.info("üìä No DAU data available")
    
    with col2:
        # Users by Role - PIE CHART
        role_query = f"""
        SELECT 
            COALESCE(role, 'Unknown') as role,
            COUNT(*) as count
        FROM {get_table_ref('user')}
        GROUP BY role
        """
        role_data = run_query(role_query, client)
        
        if role_data is not None and not role_data.empty:
            fig = px.pie(role_data, values='count', names='role',
                        title='üë• Users by Role',
                        color_discrete_sequence=px.colors.qualitative.Set3)
            fig.update_traces(textposition='inside', textinfo='percent+label')
            fig.update_layout(
                height=350,
                paper_bgcolor=theme['bg'],
                font=dict(color=theme['text'])
            )
            st.plotly_chart(fig, use_container_width=True, key="role_pie")
        else:
            st.info("üìä No role data available")
    
    # Cumulative Users - AREA CHART
    cumulative_query = f"""
    WITH daily_new AS (
        SELECT 
            DATE(date_added) as date,
            COUNT(*) as new_users
        FROM {get_table_ref('user')}
        WHERE date_added >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 90 DAY)
        GROUP BY date
        ORDER BY date
    )
    SELECT 
        date,
        SUM(new_users) OVER (ORDER BY date) as cumulative_users
    FROM daily_new
    """
    cum_data = run_query(cumulative_query, client)
    
    if cum_data is not None and not cum_data.empty:
        fig = px.area(cum_data, x='date', y='cumulative_users',
                     title='üìà Cumulative User Growth (Last 90 Days)')
        fig.update_traces(fillcolor=COLORS['primary'], line_color=COLORS['primary'])
        fig.update_layout(
            height=300,
            plot_bgcolor=theme['bg'],
            paper_bgcolor=theme['bg'],
            font=dict(color=theme['text'])
        )
        st.plotly_chart(fig, use_container_width=True, key="cumulative_area")
    
    st.divider()
    
    # ========================================================================
    # SECTION 3: LEARNING PERFORMANCE (BAR + HISTOGRAM + BOX PLOT)
    # ========================================================================
    
    st.markdown("### üìö Learning Performance Analytics")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Avg Score by Case Study - BAR CHART
        case_score_query = f"""
        SELECT 
            c.title,
            AVG(g.final_score) as avg_score,
            COUNT(g._id) as attempts
        FROM {get_table_ref('casestudy')} c
        LEFT JOIN {get_table_ref('grades')} g ON c.case_study_id = g.case_study
        GROUP BY c.title
        ORDER BY avg_score DESC
        """
        case_data = run_query(case_score_query, client)
        
        if case_data is not None and not case_data.empty:
            fig = px.bar(case_data, x='avg_score', y='title',
                        orientation='h',
                        title='üìä Average Score by Case Study',
                        color='avg_score',
                        color_continuous_scale='RdYlGn')
            fig.update_layout(
                height=400,
                showlegend=False,
                plot_bgcolor=theme['bg'],
                paper_bgcolor=theme['bg'],
                font=dict(color=theme['text'])
            )
            st.plotly_chart(fig, use_container_width=True, key="case_bar")
        else:
            st.info("üìä No case study data available")
    
    with col2:
        # Score Distribution - HISTOGRAM
        score_dist_query = f"SELECT final_score FROM {get_table_ref('grades')}"
        score_data = run_query(score_dist_query, client)
        
        if score_data is not None and not score_data.empty:
            fig = px.histogram(score_data, x='final_score',
                              nbins=20,
                              title='üìâ Score Distribution',
                              color_discrete_sequence=[COLORS['primary']])
            fig.update_layout(
                height=400,
                xaxis_title="Score",
                yaxis_title="Count",
                plot_bgcolor=theme['bg'],
                paper_bgcolor=theme['bg'],
                font=dict(color=theme['text'])
            )
            st.plotly_chart(fig, use_container_width=True, key="score_hist")
        else:
            st.info("üìä No score data available")
    
    # Performance Trend - MULTI-LINE CHART
    perf_trend_query = f"""
    SELECT 
        DATE(timestamp) as date,
        AVG(final_score) as avg_score,
        MIN(final_score) as min_score,
        MAX(final_score) as max_score
    FROM {get_table_ref('grades')}
    WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 90 DAY)
    GROUP BY date
    ORDER BY date
    """
    perf_data = run_query(perf_trend_query, client)
    
    if perf_data is not None and not perf_data.empty:
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=perf_data['date'], y=perf_data['avg_score'],
            name='Average',
            line=dict(color=COLORS['primary'], width=3)
        ))
        
        fig.add_trace(go.Scatter(
            x=perf_data['date'], y=perf_data['max_score'],
            name='Max',
            line=dict(color=COLORS['success'], width=2, dash='dash')
        ))
        
        fig.add_trace(go.Scatter(
            x=perf_data['date'], y=perf_data['min_score'],
            name='Min',
            line=dict(color=COLORS['danger'], width=2, dash='dash')
        ))
        
        fig.update_layout(
            title='üìà Performance Trend (Avg/Min/Max)',
            height=350,
            hovermode='x unified',
            plot_bgcolor=theme['bg'],
            paper_bgcolor=theme['bg'],
            font=dict(color=theme['text'])
        )
        
        st.plotly_chart(fig, use_container_width=True, key="perf_trend")
    
    st.divider()
    
    # ========================================================================
    # SECTION 4: ENGAGEMENT ANALYTICS (SCATTER + HEATMAP)
    # ========================================================================
    
    st.markdown("### ‚ö° Engagement Analytics")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Session Length Distribution - VIOLIN PLOT
        session_len_query = f"""
        SELECT derived_session_length_minutes as length
        FROM {get_table_ref('session_analytics')}
        WHERE derived_session_length_minutes IS NOT NULL
        AND derived_session_length_minutes BETWEEN 1 AND 120
        """
        session_data = run_query(session_len_query, client)
        
        if session_data is not None and not session_data.empty:
            fig = px.violin(session_data, y='length',
                           title='üéª Session Length Distribution',
                           box=True,
                           color_discrete_sequence=[COLORS['secondary']])
            fig.update_layout(
                height=400,
                yaxis_title="Minutes",
                plot_bgcolor=theme['bg'],
                paper_bgcolor=theme['bg'],
                font=dict(color=theme['text'])
            )
            st.plotly_chart(fig, use_container_width=True, key="violin")
        else:
            st.info("üìä No session data available")
    
    with col2:
        # Engagement Score Trend - LINE CHART
        eng_trend_query = f"""
        SELECT 
            DATE(start_timestamp) as date,
            AVG(derived_engagement_score) as avg_eng
        FROM {get_table_ref('session_analytics')}
        WHERE start_timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)
        AND derived_engagement_score IS NOT NULL
        GROUP BY date
        ORDER BY date
        """
        eng_data = run_query(eng_trend_query, client)
        
        if eng_data is not None and not eng_data.empty:
            fig = px.line(eng_data, x='date', y='avg_eng',
                         title='‚ö° Engagement Score Trend',
                         markers=True)
            fig.update_traces(line_color=COLORS['warning'], line_width=3)
            fig.update_layout(
                height=400,
                hovermode='x unified',
                plot_bgcolor=theme['bg'],
                paper_bgcolor=theme['bg'],
                font=dict(color=theme['text'])
            )
            st.plotly_chart(fig, use_container_width=True, key="eng_line")
        else:
            st.info("üìä No engagement data available")
    
    st.divider()
    
    # ========================================================================
    # SECTION 5: LEARNING FUNNEL (FUNNEL CHART)
    # ========================================================================
    
    st.markdown("### üéØ Learning Journey Funnel")
    
    funnel_query = f"""
    SELECT 'Registered Users' as stage, COUNT(DISTINCT user_id) as count, 1 as ord FROM {get_table_ref('user')}
    UNION ALL
    SELECT 'Started Sessions' as stage, COUNT(DISTINCT _id) as count, 2 as ord FROM {get_table_ref('sessions')}
    UNION ALL
    SELECT 'Had Conversations' as stage, COUNT(DISTINCT user) as count, 3 as ord FROM {get_table_ref('conversation')}
    UNION ALL
    SELECT 'Received Grades' as stage, COUNT(DISTINCT user) as count, 4 as ord FROM {get_table_ref('grades')}
    ORDER BY ord
    """
    funnel_data = run_query(funnel_query, client)
    
    if funnel_data is not None and not funnel_data.empty:
        fig = go.Figure(go.Funnel(
            y=funnel_data['stage'],
            x=funnel_data['count'],
            textinfo="value+percent initial",
            marker=dict(color=[COLORS['primary'], COLORS['secondary'], 
                              COLORS['success'], COLORS['warning']])
        ))
        
        fig.update_layout(
            title='üéØ User Conversion Funnel',
            height=400,
            paper_bgcolor=theme['bg'],
            font=dict(color=theme['text'])
        ))
        
        st.plotly_chart(fig, use_container_width=True, key="funnel")
    
    st.divider()
    
    # ========================================================================
    # SECTION 6: ACTIVITY HEATMAP
    # ========================================================================
    
    st.markdown("### üî• Activity Heatmap (Day √ó Hour)")
    
    heatmap_query = f"""
    SELECT 
        EXTRACT(DAYOFWEEK FROM timestamp) as day,
        EXTRACT(HOUR FROM timestamp) as hour,
        COUNT(*) as activity_count
    FROM {get_table_ref('conversation')}
    WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)
    GROUP BY day, hour
    ORDER BY day, hour
    """
    heatmap_data = run_query(heatmap_query, client)
    
    if heatmap_data is not None and not heatmap_data.empty:
        # Pivot for heatmap
        pivot = heatmap_data.pivot(index='day', columns='hour', values='activity_count').fillna(0)
        
        day_labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
        
        fig = go.Figure(data=go.Heatmap(
            z=pivot.values,
            x=pivot.columns,
            y=[day_labels[int(i-1)] for i in pivot.index],
            colorscale='Reds',
            hoverongaps=False
        ))
        
        fig.update_layout(
            title='üî• User Activity by Day & Hour',
            xaxis_title="Hour of Day",
            yaxis_title="Day of Week",
            height=400,
            plot_bgcolor=theme['bg'],
            paper_bgcolor=theme['bg'],
            font=dict(color=theme['text'])
        )
        
        st.plotly_chart(fig, use_container_width=True, key="heatmap")
    else:
        st.info("üìä No activity data for heatmap")
    
    st.divider()
    
    # ========================================================================
    # SECTION 7: DEPARTMENT COMPARISON (GROUPED BAR)
    # ========================================================================
    
    st.markdown("### üè¢ Department Performance Comparison")
    
    dept_query = f"""
    SELECT 
        COALESCE(u.department, 'No Department') as dept,
        COUNT(DISTINCT u.user_id) as students,
        AVG(g.final_score) as avg_score,
        COUNT(g._id) as attempts
    FROM {get_table_ref('user')} u
    LEFT JOIN {get_table_ref('grades')} g ON u.user_id = g.user
    GROUP BY dept
    HAVING students > 0
    ORDER BY avg_score DESC
    """
    dept_data = run_query(dept_query, client)
    
    if dept_data is not None and not dept_data.empty:
        fig = go.Figure()
        
        fig.add_trace(go.Bar(
            name='Avg Score',
            x=dept_data['dept'],
            y=dept_data['avg_score'],
            marker_color=COLORS['primary']
        ))
        
        fig.add_trace(go.Bar(
            name='Students',
            x=dept_data['dept'],
            y=dept_data['students'],
            marker_color=COLORS['secondary'],
            yaxis='y2'
        ))
        
        fig.update_layout(
            title='üè¢ Department Performance: Score vs Student Count',
            barmode='group',
            height=400,
            yaxis=dict(title='Average Score'),
            yaxis2=dict(title='Number of Students', overlaying='y', side='right'),
            plot_bgcolor=theme['bg'],
            paper_bgcolor=theme['bg'],
            font=dict(color=theme['text'])
        )
        
        st.plotly_chart(fig, use_container_width=True, key="dept_bar")
    else:
        st.info("üìä No department data available")

if __name__ == "__main__":
    render()
